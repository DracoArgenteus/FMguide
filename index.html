<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Folkemødet 2025 - Combined Event Schedule</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.7.0.js"></script>
    <!-- DataTables CSS -->
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.13.7/css/jquery.dataTables.min.css">
    <!-- DataTables JS -->
    <script type="text/javascript" charset="utf8" src="https://cdn.datatables.net/1.13.7/js/jquery.dataTables.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .dataTables_wrapper .dataTables_length,
        .dataTables_wrapper .dataTables_filter { margin-bottom: 1rem; }
        .dataTables_wrapper .dataTables_info,
        .dataTables_wrapper .dataTables_paginate { margin-top: 1rem; }
        .dataTables_wrapper .dataTables_filter input,
        .dataTables_wrapper .dataTables_length select {
            border: 1px solid #cbd5e1; border-radius: 0.375rem; padding: 0.5rem 0.75rem; margin-left: 0.5rem;
        }
        table.dataTable th { background-color: #f3f4f6; color: #1f2937; }
        .table-container { overflow-x: auto; }
        #eventTable { width: 100% !important; }
        .error-message { color: #dc2626; background-color: #fee2e2; border: 1px solid #fca5a5; padding: 1rem; border-radius: 0.375rem; margin-top: 1rem; }
        
        .filter-buttons button, .source-filter-buttons button {
            padding: 0.5rem 1rem; margin-right: 0.5rem; margin-bottom: 0.5rem;
            border-radius: 0.375rem; border: 1px solid transparent;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
        }
        .filter-buttons button.active-filter, .source-filter-buttons button.active-filter {
            background-color: #2563eb; color: white; border-color: #1d4ed8;
        }
        .filter-buttons button:not(.active-filter), .source-filter-buttons button:not(.active-filter) {
            background-color: #e5e7eb; color: #374151;
        }
        .filter-buttons button:not(.active-filter):hover, .source-filter-buttons button:not(.active-filter):hover {
            background-color: #d1d5db;
        }

        .truncate-text {
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; /* max-width is now controlled by columnDef */
            cursor: pointer; color: #2563eb; text-decoration: underline; text-decoration-style: dotted;
        }
        .truncate-text:hover { color: #1d4ed8; }
        .clickable-link { color: #2563eb; text-decoration: underline; }
        .clickable-link:hover { color: #1d4ed8; }

        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 10% auto; padding: 25px; border: 1px solid #888; width: 80%; max-width: 600px; border-radius: 0.5rem; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06); }
        .modal-header { padding-bottom: 10px; border-bottom: 1px solid #eee; font-size: 1.25rem; font-weight: 600; }
        .modal-body { padding-top:15px; padding-bottom: 15px; white-space: pre-wrap; } 
        .modal-footer { padding-top: 10px; border-top: 1px solid #eee; text-align: right; }
        .close-button { background-color: #ef4444; color: white; padding: 0.5rem 1rem; border: none; border-radius: 0.375rem; cursor: pointer; transition: background-color 0.2s; }
        .close-button:hover { background-color: #dc2626; }
        #dataFreshness { font-size: 0.875rem; color: #4b5563; margin-top: -0.5rem; margin-bottom: 1rem; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 p-4 md:p-8">

    <div class="container mx-auto max-w-7xl">
        <header class="mb-8 text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-blue-600">Folkemødet 2025 - Combined Event Schedule</h1>
            <p id="dataFreshness" class="text-gray-600">Loading data update time...</p>
            <p class="text-gray-600 mt-2">Official and Private event lists. Use filters to browse.</p>
        </header>

        <div id="instructions" class="mb-4 p-6 bg-blue-50 border border-blue-200 rounded-lg shadow">
            <h2 class="text-xl font-semibold text-blue-700 mb-3">How to Use This Page</h2>
            <ol class="list-decimal list-inside space-y-1 text-gray-700">
                <li>Ensure `data/folkemoedet_private_events.csv` and `data/official_events_combined.csv` exist.</li>
                <li>Use the "Source" buttons to switch between Official, Private, or All events.</li>
                <li>Use the "Day" buttons to filter by weekday.</li>
                <li>Click on truncated descriptions or links for more details.</li>
            </ol>
        </div>
        
        <div id="tableErrorMessage" class="hidden error-message"></div>

        <!-- Source Filter Buttons -->
        <div class="source-filter-buttons mb-4 text-center sm:text-left">
            <h3 class="text-lg font-semibold mb-2 text-gray-700">Filter by Source:</h3>
            <button data-source="All" class="active-filter">All Sources</button>
            <button data-source="Official">Official Program</button>
            <button data-source="Private">Private List</button>
        </div>

        <!-- Weekday Filter Buttons -->
        <div class="filter-buttons mb-6 text-center sm:text-left">
            <h3 class="text-lg font-semibold mb-2 text-gray-700">Filter by Day:</h3>
            <button data-day="All" class="active-filter">All Days</button>
            <button data-day="Torsdag">Torsdag</button>
            <button data-day="Fredag">Fredag</button>
            <button data-day="Lørdag">Lørdag</button>
        </div>

        <div class="bg-white p-4 sm:p-6 rounded-lg shadow-lg table-container">
            <table id="eventTable" class="display cell-border hover order-column stripe" style="width:100%">
                <thead></thead>
                <tbody></tbody>
            </table>
        </div>

        <footer class="mt-12 text-center text-sm text-gray-500">
            <p>&copy; <span id="currentYear"></span> Folkemødet Event Viewer.</p>
        </footer>
    </div>

    <!-- Modal Structure -->
    <div id="descriptionModal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span id="modalTitle">Event Description</span></div>
            <div class="modal-body"><p id="modalFullDescription"></p></div>
            <div class="modal-footer"><button id="closeModalButton" class="close-button">Close</button></div>
        </div>
    </div>

    <script>
        document.getElementById('currentYear').textContent = new Date().getFullYear();

        const UNIFIED_HEADERS = [
            "EventTitle", "Weekday", "TimeRange", "Location", 
            "Description", "EventURL", "Organizers", "Theme", "DataSource" 
        ];
        
        const privateDataMap = {
            "EventTitle": "EventTitle", "Weekday": "Weekday", "TimeRange": "TimeRange", 
            "Description": "Description", "EventURL": "EventURL", 
            "Organizers": "Organizers", "Theme": "Theme", "Location": "Location",
            "DataSource": "DataSource", "OriginalSourceDoc": "OriginalSourceDoc"
        };

        const officialDataMap = {
            "title": "EventTitle", "day_date": "_FullDate", 
            "startTime": "_StartTime", "endTime": "_EndTime", 
            "location": "Location", "summary": "Description", 
            // No direct 'url' anymore, we added specific parts
            "eventYear": "_OfficialYear", 
            "eventCrmId": "_OfficialCrmId", 
            "eventSlug": "_OfficialSlug",
            "organizers": "Organizers", "theme": "Theme"
        };


        $(document).ready(function() {
            const privateCsvPath = 'data/folkemoedet_private_events.csv'; 
            const officialCsvPath = 'data/official_events_combined.csv';
            
            const tableErrorMessageDiv = document.getElementById('tableErrorMessage');
            const dataFreshnessElement = document.getElementById('dataFreshness');
            let eventDataTable = null;
            let allNormalizedEvents = []; 

            const modal = document.getElementById('descriptionModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalFullDescription = document.getElementById('modalFullDescription');
            const closeModalButton = document.getElementById('closeModalButton');

            function robustParseCSV(csvText) {
                const data = [];
                let headers = [];
                const normalizedCsvText = csvText.trim().replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                const lines = [];
                let inQuotes = false;
                let currentLine = "";
                for (let i = 0; i < normalizedCsvText.length; i++) {
                    const char = normalizedCsvText[i];
                    currentLine += char;
                    if (char === '"') {
                        if (i + 1 < normalizedCsvText.length && normalizedCsvText[i+1] === '"') {
                            currentLine += '"'; i++;
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === '\n' && !inQuotes) {
                        lines.push(currentLine.trim());
                        currentLine = "";
                    }
                }
                if (currentLine.trim()) { lines.push(currentLine.trim()); }
                if (lines.length === 0) return { headers, data };

                const splitCsvFields = (line) => {
                    const fields = []; let currentField = ""; let inFieldQuotes = false;
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        if (char === '"') {
                            if (inFieldQuotes && i + 1 < line.length && line[i+1] === '"') {
                                currentField += '"'; i++; 
                            } else { inFieldQuotes = !inFieldQuotes; }
                        } else if (char === ',' && !inFieldQuotes) {
                            fields.push(currentField); currentField = "";
                        } else { currentField += char; }
                    }
                    fields.push(currentField); 
                    return fields.map(field => field.replace(/^"|"$/g, '').replace(/""/g, '"'));
                };
                headers = splitCsvFields(lines[0]);
                for (let i = 1; i < lines.length; i++) {
                    if (lines[i].trim() === "") continue;
                    const values = splitCsvFields(lines[i]);
                    if (values.length === headers.length) {
                        let row = {};
                        headers.forEach((header, index) => { row[header.trim()] = values[index]; });
                        data.push(row);
                    } else { console.warn(`Skipping malformed CSV line (field count mismatch): Line ${i+1} -> Content: "${lines[i]}"`, "Expected", headers.length, "fields, got", values.length, "Values:", values); }
                }
                return { headers, data };
            }

            function formatTime(ptTime) { 
                if (!ptTime || !ptTime.startsWith('PT')) return '';
                let hours = '00', minutes = '00';
                const H_match = ptTime.match(/(\d+)H/);
                const M_match = ptTime.match(/(\d+)M/);
                if (H_match) hours = H_match[1].padStart(2, '0');
                if (M_match) minutes = M_match[1].padStart(2, '0');
                return `${hours}:${minutes}`;
            }

            function dayDateToWeekday(dateString) { 
                if (!dateString) return '';
                try {
                    const date = new Date(dateString + 'T00:00:00Z'); 
                    if (isNaN(date.getDay())) { 
                        console.warn("Invalid date string for dayDateToWeekday:", dateString);
                        return 'Invalid Date';
                    }
                    const weekdays = ["Søndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lørdag"];
                    return weekdays[date.getDay()];
                } catch (e) {
                    console.warn("Error parsing date in dayDateToWeekday:", dateString, e);
                    return 'Date Error';
                }
            }
            
            function timeAgo(date) {
                if (!date) return "unknown";
                const seconds = Math.floor((new Date() - date) / 1000);
                let interval = seconds / 31536000;
                if (interval > 1) return Math.floor(interval) + " years ago";
                interval = seconds / 2592000;
                if (interval > 1) return Math.floor(interval) + " months ago";
                interval = seconds / 86400;
                if (interval > 1) return Math.floor(interval) + " days ago";
                interval = seconds / 3600;
                if (interval > 1) return Math.floor(interval) + " hours ago";
                interval = seconds / 60;
                if (interval > 1) return Math.floor(interval) + " minutes ago";
                return Math.floor(seconds) + " seconds ago";
            }


            function normalizeData(rawData, sourceName, map) {
                return rawData.map((rawEvent, index) => { 
                    const normalizedEvent = { DataSource: sourceName }; 
                    UNIFIED_HEADERS.forEach(header => {
                        if (header !== 'DataSource') {
                           normalizedEvent[header] = ''; 
                        }
                    });
                    
                    for (const rawHeader in map) {
                        const unifiedHeader = map[rawHeader];
                        if (rawEvent.hasOwnProperty(rawHeader)) {
                            normalizedEvent[unifiedHeader] = rawEvent[rawHeader];
                        }
                    }

                    if (sourceName === "Official") {
                        normalizedEvent.Weekday = dayDateToWeekday(normalizedEvent._FullDate);
                        const startTimeFormatted = formatTime(normalizedEvent._StartTime);
                        const endTimeFormatted = formatTime(normalizedEvent._EndTime);
                        if (startTimeFormatted && endTimeFormatted && startTimeFormatted !== endTimeFormatted) {
                            normalizedEvent.TimeRange = `${startTimeFormatted}-${endTimeFormatted}`;
                        } else if (startTimeFormatted) {
                            normalizedEvent.TimeRange = startTimeFormatted;
                        }
                        // Construct EventURL from parts
                        if (normalizedEvent._OfficialYear && normalizedEvent._OfficialCrmId && normalizedEvent._OfficialSlug) {
                            normalizedEvent.EventURL = `https://programoversigt.folkemoedet.dk/events/${normalizedEvent._OfficialYear}/${normalizedEvent._OfficialCrmId}/${normalizedEvent._OfficialSlug}`;
                        }
                        delete normalizedEvent._FullDate; delete normalizedEvent._StartTime; delete normalizedEvent._EndTime;
                        delete normalizedEvent._OfficialYear; delete normalizedEvent._OfficialCrmId; delete normalizedEvent._OfficialSlug;
                    }
                    
                    if (index < 1) { 
                        console.log(`Normalized event sample from ${sourceName}. DataSource: '${normalizedEvent.DataSource}', EventURL: '${normalizedEvent.EventURL}'`);
                    }
                    return normalizedEvent;
                });
            }
            
            let lastModifiedTimestamps = [];

            Promise.all([
                fetch(privateCsvPath).then(response => {
                    if (!response.ok) { 
                        console.error(`Failed to load ${privateCsvPath}: ${response.status} ${response.statusText}`); 
                        tableErrorMessageDiv.innerHTML += `<p>Error loading private events: ${response.statusText}</p>`;
                        tableErrorMessageDiv.classList.remove('hidden');
                        return {text: () => Promise.resolve(""), headers: {get: () => null}}; 
                    }
                    lastModifiedTimestamps.push(response.headers.get('Last-Modified'));
                    return response.text();
                }).then(csvText => normalizeData(robustParseCSV(csvText).data, "Private", privateDataMap))
                  .catch(err => {
                      console.error(`Error processing ${privateCsvPath}:`, err);
                      tableErrorMessageDiv.innerHTML += `<p>Error processing private events file.</p>`;
                      tableErrorMessageDiv.classList.remove('hidden');
                      return []; 
                  }),
                
                fetch(officialCsvPath).then(response => {
                    if (!response.ok) { 
                        console.error(`Failed to load ${officialCsvPath}: ${response.status} ${response.statusText}`); 
                        tableErrorMessageDiv.innerHTML += `<p>Error loading official events: ${response.statusText}.</p>`;
                        tableErrorMessageDiv.classList.remove('hidden');
                        return {text: () => Promise.resolve(""), headers: {get: () => null}}; 
                    }
                    lastModifiedTimestamps.push(response.headers.get('Last-Modified'));
                    return response.text();
                }).then(csvText => normalizeData(robustParseCSV(csvText).data, "Official", officialDataMap))
                  .catch(err => {
                      console.error(`Error processing ${officialCsvPath}:`, err);
                       tableErrorMessageDiv.innerHTML += `<p>Error processing official events file.</p>`;
                       tableErrorMessageDiv.classList.remove('hidden');
                      return []; 
                  })
            ])
            .then(([privateEvents, officialEvents]) => {
                const validDates = lastModifiedTimestamps.filter(d => d !== null).map(d => new Date(d));
                if (validDates.length > 0) {
                    const mostRecentDate = new Date(Math.max.apply(null, validDates));
                    dataFreshnessElement.textContent = `Data last updated: ${mostRecentDate.toLocaleString()} (${timeAgo(mostRecentDate)})`;
                } else {
                    dataFreshnessElement.textContent = "Data update time: Not available";
                }

                allNormalizedEvents = privateEvents.concat(officialEvents);
                console.log(`Total normalized events: ${allNormalizedEvents.length} (Private: ${privateEvents.length}, Official: ${officialEvents.length})`);
                                
                if (allNormalizedEvents.length === 0) {
                     if (!tableErrorMessageDiv.classList.contains('hidden') && tableErrorMessageDiv.textContent.includes("Error")) {
                        // Error already shown
                     } else {
                        tableErrorMessageDiv.textContent = "No event data loaded. Ensure 'data/folkemoedet_private_events.csv' and 'data/official_events_combined.csv' exist, contain data, and are correctly formatted.";
                        tableErrorMessageDiv.classList.remove('hidden');
                     }
                } else {
                    tableErrorMessageDiv.classList.add('hidden');
                }

                let headerHtml = '<tr>';
                UNIFIED_HEADERS.forEach(header => {
                    headerHtml += `<th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${header.replace(/([A-Z])/g, ' $1').trim()}</th>`;
                });
                headerHtml += '</tr>';
                $('#eventTable thead').html(headerHtml);

                const colIdx = {};
                UNIFIED_HEADERS.forEach((header, i) => colIdx[header] = i);

                eventDataTable = $('#eventTable').DataTable({
                    data: allNormalizedEvents.map(event => UNIFIED_HEADERS.map(header => event[header])),
                    responsive: true,
                    lengthMenu: [[25, 50, 100, -1], [25, 50, 100, "All"]],
                    pageLength: 25,
                    language: { search: "_INPUT_", searchPlaceholder: "Search all fields...", lengthMenu: "Show _MENU_ entries", zeroRecords: "No matching events found for the current filters.", emptyTable: "No events loaded or selected for display." },
                    order: [[colIdx.Weekday, 'asc'], [colIdx.TimeRange, 'asc']], 
                    columnDefs: [ 
                        { width: '10%', targets: colIdx.Weekday },
                        { width: '10%', targets: colIdx.TimeRange },
                        { width: '15%', targets: colIdx.Location, 
                          render: function (data, type, row, meta) {
                            if (type === 'display' && data) {
                                const baseUrl = "https://programoversigt.folkemoedet.dk/";
                                const encodedLocation = encodeURIComponent(data);
                                return `<a href="${baseUrl}?location=${encodedLocation}" target="_blank" class="clickable-link" title="View ${data} on Folkemødet map">${data}</a>`;
                            } return data;
                          }
                        },
                        { 
                            width: '20%', 
                            targets: colIdx.Description, 
                            render: function (data, type, row, meta) {
                                if (type === 'display' && data) {
                                    const fullText = data; 
                                    const maxLength = 40; 
                                    if (fullText.length > maxLength) {
                                        const escapedFullText = fullText.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                        return `<span class="truncate-text" style="max-width: 200px;" title="Click to read more" data-fulltext="${escapedFullText}">${fullText.substring(0, maxLength)}...</span>`; 
                                    }
                                } return data || ''; 
                            }
                        },
                        { targets: colIdx.EventURL,
                          render: function(data, type, row, meta) {
                            if (type === 'display' && data && (data.startsWith('http://') || data.startsWith('https://'))) {
                                return `<a href="${data}" target="_blank" class="clickable-link" title="View event details">View Event</a>`;
                            } return data || ''; 
                          }
                        },
                         { targets: colIdx.DataSource, className: "dt-body-center", width: "10%" } 
                    ]
                });
                applyFilters();
            })
            .catch(error => { 
                console.error('General error loading or processing CSV data:', error);
                tableErrorMessageDiv.textContent = `General Error: ${error.message}. Check console and CSV files.`;
                tableErrorMessageDiv.classList.remove('hidden');
                 dataFreshnessElement.textContent = "Could not determine data update time.";
            });

            let currentSourceFilter = "All";
            let currentDayFilter = "All";

            function applyFilters() {
                if (!eventDataTable) {
                    console.log("DataTable not initialized yet. Skipping applyFilters.");
                    return;
                }
                console.log(`Applying filters - Source: ${currentSourceFilter}, Day: ${currentDayFilter}`);
                
                const dataSourceColIdx = UNIFIED_HEADERS.indexOf("DataSource");
                const weekdayColIdx = UNIFIED_HEADERS.indexOf("Weekday");

                if (dataSourceColIdx === -1 || weekdayColIdx === -1) {
                    console.error("Could not find DataSource or Weekday column index. UNIFIED_HEADERS:", UNIFIED_HEADERS);
                    return;
                }

                if (eventDataTable.rows().count() > 0) {
                    try {
                        const uniqueDataSources = eventDataTable.column(dataSourceColIdx).data().unique().toArray();
                        console.log("DEBUG: Unique DataSource values in table before filtering:", uniqueDataSources);
                    } catch(e) {
                        console.warn("Could not get unique DataSource values for debugging.", e);
                    }
                } else {
                    console.log("Table has no data when trying to log unique DataSource values.");
                }

                let sourceSearchTermRegex = (currentSourceFilter === "All") ? '' : '^' + currentSourceFilter + '$';
                eventDataTable.column(dataSourceColIdx).search(sourceSearchTermRegex, true, false, true).draw(false);

                let daySearchTermRegex = (currentDayFilter === "All") ? '' : '^' + currentDayFilter + '$';
                eventDataTable.column(weekdayColIdx).search(daySearchTermRegex, true, false, true); 

                eventDataTable.draw(); 
                console.log("Table redrawn with filters. Matching rows:", eventDataTable.rows({ search: 'applied' }).count());
            }

            $('.source-filter-buttons button').on('click', function() {
                currentSourceFilter = $(this).data('source');
                $('.source-filter-buttons button').removeClass('active-filter');
                $(this).addClass('active-filter');
                applyFilters();
            });

            $('.filter-buttons button').on('click', function() {
                currentDayFilter = $(this).data('day');
                $('.filter-buttons button').removeClass('active-filter');
                $(this).addClass('active-filter');
                applyFilters();
            });

            $('#eventTable tbody').on('click', 'span.truncate-text', function () {
                const fullText = $(this).data('fulltext');
                const rowDataArray = eventDataTable.row($(this).closest('tr')).data();
                const titleColIdx = UNIFIED_HEADERS.indexOf("EventTitle");
                const eventTitleForRow = rowDataArray[titleColIdx] || "Event Details";
                
                modalTitle.textContent = eventTitleForRow;
                modalFullDescription.textContent = fullText;
                modal.style.display = "block";
            });

            closeModalButton.onclick = function() { modal.style.display = "none"; }
            window.onclick = function(event) { if (event.target == modal) { modal.style.display = "none"; } }
        });
    </script>
</body>
</html>
